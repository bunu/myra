/*
 * FindRulesActivity.java
 * (this file is part of MYRA)
 * 
 * Copyright 2008-2015 Fernando Esteban Barril Otero
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package myra.rule.michigan;

import static myra.Config.CONFIG;
import static myra.Dataset.NOT_COVERED;
import static myra.Dataset.RULE_COVERED;
import static myra.rule.Heuristic.DEFAULT_HEURISTIC;
import static myra.rule.irl.PheromonePolicy.DEFAULT_POLICY;
import static myra.rule.michigan.cAntMinerM.CLASSIFIER;

import java.util.List;

import myra.Archive;
import myra.Dataset;
import myra.Dataset.Instance;
import myra.IterativeActivity;
import myra.Config.ConfigKey;
import myra.rule.Graph;
import myra.rule.Rule;
import myra.rule.RuleList;
import myra.rule.RuleSet;
import myra.rule.Graph.Entry;
import myra.rule.irl.PheromonePolicy;

/**
 * The <code>FineRulesActivity</code> is responsible for evolving a single rule
 * using an ACO-based procedure.
 * 
 * The Activity uses the inherited create method for each rule however the
 * update mechanism is varied to include a niching operation.
 * 
 * @author James Brookhouse
 *
 */
public class FindRulesActivity extends IterativeActivity<Rule> {

	public final static ConfigKey<Double> UPDATE_THRESHOLD = new ConfigKey<>();

	/**
	 * Instance flag array indicating the instances to be used during the
	 * construction procedure.
	 */
	private Instance[] instances;

	/**
	 * The current dataset.
	 */
	private Dataset dataset;

	/**
	 * The construction graph.
	 */
	private Graph graph;

	/**
	 * The ACO pheromone policy.
	 */
	private PheromonePolicy policy;

	/**
	 * The heuristic values for the graph's vertices.
	 */
	private Entry[] heuristic;

	/**
	 * Creates a new <code>FindRulesActivity</code> object.
	 * 
	 * @param graph
	 *            the construction graph.
	 * @param instances
	 *            the instances to be used.
	 * @param training
	 *            the current dataset.
	 */
	public FindRulesActivity(Graph graph, Instance[] instances, Dataset training) {
		this.graph = graph;
		this.instances = instances;
		this.dataset = training;
	}

	@Override
	public Rule create() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void initialise() {
		super.initialise();

		policy = CONFIG.get(DEFAULT_POLICY);
		policy.initialise(graph);

		// the heuristic procedure only takes into account
		// the instances covered by a rule, so we prepare an
		// instance array where each NOT_COVERED value is
		// replaced by a RULE_COVERED value

		Instance[] clone = Instance.copyOf(instances);
		Instance.mark(clone, NOT_COVERED, RULE_COVERED);

		heuristic = CONFIG.get(DEFAULT_HEURISTIC).compute(graph, dataset, clone);
	}

	@Override
	public boolean terminate() {
		return super.terminate() || stagnation > CONFIG.get(STAGNATION);
	}

	@Override
	public void update(Archive<Rule> archive) {
		super.update(archive);
		Rule[] rules = archive.topN(archive.size());
		for (Rule rule : rules) {
			if (rule.getQuality() >= CONFIG.get(UPDATE_THRESHOLD)) {
				policy.update(graph, rule);
			} else {
				// Its an ordered fitness list so when we drop below the
				// threshold we can just stop.
				break;
			}
		}
		policy.finaliseUpdate(graph);
		niching(archive);
	}

	private void niching(Archive<Rule> archive) {
		Rule[] rules = mergeRules(archive, CONFIG.get(CLASSIFIER).rules());

		// TODO: complete method body
	}

	/**
	 * Merges the list generated by this iteration and the rules already present
	 * in the classifier ready for niching
	 * 
	 * @param archive
	 *            the archive of rules created in this iteration
	 * @param classifier
	 *            the current best classifier rule collection
	 * @return the merged list of rules
	 */
	private Rule[] mergeRules(Archive<Rule> archive, Rule[] classifier) {

		Rule[] rules = new Rule[archive.size() + classifier.length];
		int i = 0;
		for (Rule r : archive.topN(archive.size())) {
			rules[i] = r;
			i++;
		}
		for (Rule r : classifier) {
			rules[i] = r;
			i++;
		}
		return rules;
	}
}
